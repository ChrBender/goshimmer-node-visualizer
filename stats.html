<html>

<head>
    <title>goshimmer stats</title>
  <style>
    body {
      background-color: #202225;
      margin: 0;
      color: white;
    }
    table {
      border-spacing: 1;
      width: 40%;
      border: 1px solid rgb(110, 109, 109);
    }
    th, td {
      text-align: left;
      padding: 16px;
    }
    tr:nth-child(even) {
      background-color: #565a611c
    }
  </style>
  <script src="./3d-force-graph"></script>
</head>

<body>
    <div style="padding: 10px;">
        <span style="color:#7fff7f;  padding-right: 10px" id="nodes_online">Nodes online: 0</span>
        <span style="color:#ffcc7f;  padding-right: 10px" id="neighbors_avg">Avg. number of neighbors: 0</span>
        <a style="padding-left: 120px" href="index.html">3d view</a>
    </div> 
    
    <div>

      <table id="table">
        <tr>
          <th>ID</th>
          <th>neighbors</th>
        </tr>
      </table>
    </div>


  <script>
	var socket = new WebSocket(((window.location.protocol === "https:") ? "wss://" : "ws://") + "159.69.158.51" + "/datastream");

	socket.onopen = function () {
        setInterval(function() {
          socket.send("_");
        }, 1000);
	};

	socket.onmessage = function (e) {
        switch (e.data[0]) {
          case "_":
            // do nothing - its just a ping
          break;

          case "A":
             addNode(e.data.substr(1));
          break;

          case "a":
             removeNode(e.data.substr(1));
          break;

          case "C":
             connectNodes(e.data.substr(1, 40), e.data.substr(41, 40));
          break;

          case "c":
             disconnectNodes(e.data.substr(1, 40), e.data.substr(41, 40));
          break;

          case "O":
             setNodeOnline(e.data.substr(1));
          break;

          case "o":
             setNodeOffline(e.data.substr(1));
          break;
        }
	};

    var onlineNodes = []
    var onlineNodesNeighborcount = []
    var nodesById = {};
    var existingLinks = {};
    const data = {
      nodes: [],
      links: []
    };


    firstrun()
    async function firstrun(){
      await new Promise(resolve => setTimeout(resolve, 300));
      update()
    }

    setInterval(function() {
      update()
    }, 5000)


    function update(){
      let onlinn = data.nodes.filter(n => n.online)
      onlineNodes = onlinn.map(n => n.id)
      document.getElementById("nodes_online").innerHTML = "Nodes online: "+onlineNodes.length
      
      neighborcount()
      let avgneighbors = average( onlineNodesNeighborcount); 
      document.getElementById("neighbors_avg").innerHTML = "Avg. number of neighbors: "+avgneighbors.toFixed(2)

      let nodeData = []
      for (let k = 0; k < onlineNodes.length; k++) {
        nodeData[k] = {"node":onlineNodes[k], "neighborcount":onlineNodesNeighborcount[k]}
      }
      updateTable(nodeData);
    }

    const average = arr => arr.reduce( ( p, c ) => p + c, 0 ) / arr.length;

    function neighborcount() {
      onlineNodesNeighborcount=[]
      for (let k = 0; k < onlineNodes.length; k++) {
        let nodeid = onlineNodes[k]
        let links = 0
        let neighbors = []
        for (let j = 0; j < data.links.length; j++) {
          if (data.links[j].source == nodeid || data.links[j].target == nodeid) {
            if (data.links[j].source == nodeid && neighbors.indexOf(data.links[j].target) == -1) {
              neighbors.push(data.links[j].target)
              links++
            } else if (data.links[j].target == nodeid && neighbors.indexOf(data.links[j].source) == -1) {
              neighbors.push(data.links[j].source)
              links++
            }
          }
        }
        onlineNodesNeighborcount.push(links)
      }
    }

    function updateTable(nodeData) {
      var Table = document.getElementById("table");
      Table.innerHTML = "<tr>\r\n<th>ID<\/th>\r\n<th>neighbors<\/th>\r\n<\/tr>";
        nodeData.sort(function (a, b) {
        return ((a.neighborcount > b.neighborcount) ? -1 : ((a.neighborcount == b.neighborcount) ? 0 : 1));
      });


      for (let j = 0; j < nodeData.length; j++) {
        var x = document.getElementById('table').insertRow();
        var y = x.insertCell(0);
        var z = x.insertCell(1);
        y.innerHTML = nodeData[j].node;
        z.innerHTML = nodeData[j].neighborcount;
      }
    }

    function addNode(nodeId, displayImmediately) {
      node = {id : nodeId, online: false};

      if (!(node.id in nodesById)) {
        data.nodes = [...data.nodes, node];
        nodesById[node.id] = node;
      }
    }

    function removeNode(nodeId) {
      data.links = data.links.filter(l => l.source.id !== nodeId && l.target.id !== nodeId);
      data.nodes = data.nodes.filter(currentNode => currentNode.id != nodeId)

      delete nodesById[nodeId];
    }

    function setNodeOnline(nodeId) {
      if (nodeId in nodesById) {
        nodesById[nodeId].online = true;
      }
    }

    function setNodeOffline(nodeId) {
      if (nodeId in nodesById) {
        nodesById[nodeId].online = false;
      }
    }

    function connectNodes(sourceNodeId, targetNodeId) {
      if(existingLinks[sourceNodeId + targetNodeId] == undefined && existingLinks[targetNodeId + sourceNodeId] == undefined) {
        data.links = [...data.links, { source: sourceNodeId, target: targetNodeId }];
      }
    }

    function disconnectNodes(sourceNodeId, targetNodeId) {
      data.links = data.links.filter(l => !(l.source.id == sourceNodeId && l.target.id == targetNodeId) && !(l.source.id == targetNodeId && l.target.id == sourceNodeId));

      delete existingLinks[sourceNodeId + targetNodeId];
      delete existingLinks[targetNodeId + sourceNodeId];
    }

  </script>
</body></html>
